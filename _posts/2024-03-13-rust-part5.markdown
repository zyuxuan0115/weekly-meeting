---
layout: post
title:  "2024-03-13 Rust part5 (concurrency)"
date:   2024-03-13 1:53:49 -0500
categories: serverless functions
---

## Chapter 16
### Creating a New Thread

```rust 
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
```

The return type of `thread::spawn` is `JoinHandle`. A `JoinHandle` is an owned value that, when we call the join method on it, will wait for its thread to finish.

### Using move Closures with Threads

```rust 
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```

### Using Message Passing to Transfer Data Between Threads

Rust's standard library provides an implementation of channels. A channel is a general programming concept by which data is sent from one thread to another.


`mpsc` stands for <strong>multiple producer, single consumer</strong>.

A channel can have multiple sending ends that produce values but only one receiving end.

The mpsc::channel function returns a tuple (tx, rx): 
- `tx`: transmitter 
- `rx`: receiver

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```

- The `send` method returns a `Result<T, E>` type
	+ if the receiver has already been dropped and there’s nowhere to send a value, the send operation will return an error
- The `recv` will return a `Result<T, E>`. 
	+ When the transmitter closes, recv will return an error to signal that no more values will be coming.
- The `try_recv` method doesn’t block
	+ but will instead return a `Result<T, E>` immediately

### Channels and Ownership Transference

The `send` function takes ownership of its parameter, and when the value is moved, the receiver takes ownership of it.

### Sending Multiple Values and Seeing the Receiver Waiting

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }
}
```

In the main thread, we’re not calling the `recv` function explicitly anymore: instead, we’re treating `rx` as an iterator.

### Creating Multiple Producers by Cloning the Transmitter

```rust
   let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }
```

### Shared-State Concurrency

#### mutex

```rust 
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {:?}", m);
}
```

The type of m is `Mutex<i32>`, not `i32`, so we must call lock to be able to use the `i32` value.

the call to lock returns a smart pointer called `MutexGuard`, wrapped in a `LockResult` that we handled with the call to `unwrap`.
- The `MutexGuard` smart pointer implements `Deref` to point at our inner data; 
- The smart pointer also has a `Drop` implementation that releases the lock automatically when a `MutexGuard` goes out of scope, which happens at the end of the inner scope.
	+ we don't need to release the lock since the program will release the lock automatically for us

### Sharing mutex between multiple thread
#### Atomic Reference Counting with Arc

- `Arc<T>` is a type like `Rc<T>` that is safe to use in concurrent situations. 

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

`counter` is immutable but we could get a mutable reference to the value inside it; this means `Mutex<T>` provides interior mutability, as the Cell family does.

`Mutex<T>` comes with the risk of creating deadlocks. 

### Allowing Transference of Ownership Between Threads with Send

- The `Send` marker trait indicates that ownership of values of the type implementing `Send` can be transferred between threads. 
	+ Almost every Rust type is Send, but there are some exceptions	
		* `Rc<T>` cannot be Send because if you cloned an `Rc<T>` value and tried to transfer ownership of the clone to another thread, both threads might update the reference count at the same time. 

### Allowing Access from Multiple Threads with Sync

- The `Sync` marker trait indicates that it is safe for the type implementing `Sync` to be referenced from multiple threads.

- `T` is Sync if `&T` (an immutable reference to `T`) is Send, meaning the reference can be sent safely to another thread.
	+ The smart pointer `Rc<T>` is also not `Sync`. 
	+ The `RefCell<T>` type and the family of related `Cell<T>` types are not `Sync`.

- Manually implementing `send` & `sync` traits involves implementing unsafe Rust code.


## Chapter 17 Object-Oriented Programming
### OOP feature
- objects
- encapsulation
- inheritance 
	+ You would choose inheritance for two main reasons
	+ reuse that implementation for a different type: rust - trait
	+ polymorphism: to enable a child type to be used in the same places as the parent type

## Chapter 18 
### match Arms

```rust
match x {
    None => None,
    Some(i) => Some(i + 1),
}
```

### Conditional if let Expressions

```rust
fn main() {
    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {color}, as the background");
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age > 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}
```

The downside of using `if let` expressions is that the compiler doesn’t check for exhaustiveness, whereas with `match` expressions it does.

### while let Conditional Loops

```rust
let mut stack = Vec::new();

stack.push(1);
stack.push(2);
stack.push(3);

while let Some(top) = stack.pop() {
   println!("{}", top);
}
```

### for Loops

```rust
let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
   println!("{} is at index {}", value, index);
} 
```

### let statement

```rust
let (x, y, z) = (1, 2, 3);
```

### Function Parameters

```rust
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({}, {})", x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}
```

### Refutability: Whether a Pattern Might Fail to Match
- Patterns that will match for any possible value passed are <strong>irrefutable</strong>.
	+ for example: `let x = 5;`
- Patterns that can fail to match for some possible value are <strong>refutable</strong>.
	+ `let Some(x) = some_option_value;` doesn't work.
	+ `if let x = 5 {println!("{}",x;)}` doesn't work.
- but this works

```rust
if let Some(x) = some_option_value {
  println!("{}", x);
}
```

### Matching Named Variables

```rust
let x = Some(5);
let y = 10;

match x {
  Some(50) => println!("Got 50"),
  Some(y) => println!("Matched, y = {y}"),
  _ => println!("Default case, x = {:?}", x),
}

println!("at the end: x = {:?}, y = {y}", x);
```

- `Some(y)` is different from `let y=10`

- match multiple patterns using the `|` syntax

```rust
let x = 1;

match x {
  1 | 2 => println!("one or two"),
  3 => println!("three"),
  _ => println!("anything"),
}
```

- The `..=` syntax allows us to match to an inclusive range of values.

```rust
let x = 'c';

match x {
  'a'..='j' => println!("early ASCII letter"),
  'k'..='z' => println!("late ASCII letter"),
  _ => println!("something else"),
}
```

### Destructuring Structs

```rust
struct Point {
    x: i32,
    y: i32,
}
fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
```

```rust
struct Point {
    x: i32,
    y: i32,
}
fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
```

```rust
fn main() {
    let p = Point { x: 0, y: 7 };
    match p {
        Point { x, y: 0 } => println!("On the x axis at {x}"),
        Point { x: 0, y } => println!("On the y axis at {y}"),
        Point { x, y } => {
            println!("On neither axis: ({x}, {y})");
        }
    }
}
```

### Destructuring Enums


