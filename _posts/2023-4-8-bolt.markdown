---
layout: post
title:  "2023-4-8 BOLT's address relocation"
date:   2023-4-8 7:53:46 -0500
categories: cont-opt 
---
### Binary Loop
- BOLT has a [BinaryLoop class](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/include/bolt/Core/BinaryLoop.h)
- BOLT also has a [LoopInversion pass](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Passes/LoopInversionPass.cpp)
- Our static optimization tools:
	+ [apt-get's pass](https://github.com/upenn-acg/floar/blob/master/apt-get/SWPrefetchingLLVMPass/SWPrefetchingLLVMPass.cpp)
	+ [DMon's pass](https://github.com/upenn-acg/floar/blob/master/dmon/llvm-passes/selective-prefetch/Prefetch.cpp)
	+ [LoopDataPrefetch's pass](https://llvm.org/doxygen/LoopDataPrefetch_8cpp_source.html)
- Things in APT-GET that might not be supported at Binary Level
	+ [Loop->makeLoopInvariant()](https://github.com/upenn-acg/floar/blob/master/apt-get/SWPrefetchingLLVMPass/SWPrefetchingLLVMPass.cpp#L270): several locations (I just listed one)
	+ PhiNode: a lot of locations (I just listed some of them)
		* [PHINode* getCanonicalishInductionVariable(Loop* L);](https://github.com/upenn-acg/floar/blob/master/apt-get/SWPrefetchingLLVMPass/SWPrefetchingLLVMPass.cpp#L47)
		* `if(PHINode* CurOpIsPhiNode=dyn_cast<PHINode>(op->get()))` [here](https://github.com/upenn-acg/floar/blob/master/apt-get/SWPrefetchingLLVMPass/SWPrefetchingLLVMPass.cpp#L118)
		* `PHINode *PN = cast<PHINode>(I);` [here](https://github.com/upenn-acg/floar/blob/master/apt-get/SWPrefetchingLLVMPass/SWPrefetchingLLVMPass.cpp#L361)
- Things in DMon that might not be supported at Binary Level
	+ [Loop->isLoopInvariant()](https://github.com/upenn-acg/floar/blob/master/dmon/llvm-passes/selective-prefetch/Prefetch.cpp#L286)
	+ [SCEV related](https://github.com/upenn-acg/floar/blob/master/dmon/llvm-passes/selective-prefetch/Prefetch.cpp#L291)
- [CFG of pagerank](/data-cache/2023/02/25/CFG.html)



### Check when BinaryFunction's outputAddress is updated
- the `OutputAddress` of a Binary Function is declared [here](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/include/bolt/Core/BinaryFunction.h#L226)
	+ The value of `OutputAddress` is updated [here](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Core/BinaryFunction.cpp#L4077)
	+ In this [line](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Core/BinaryFunction.cpp#L4089) of `BinaryFunction::updateOutputValues()`
		* `if (BC.HasRelocations || isInjected())`
		* we know that if the function is injected, the `OutputAddress` will be set by `setOutputAddress(BaseAddress + StartOffset);`
		* where `BaseAddress = getCodeSection()->getOutputAddress();`
		* and `StartOffset = Layout.getSymbolOffset(*getSymbol());`
	+ The <strong>callers</strong> of `BinaryFunction::updateOutputValues()` should have all information about the moved functions:
		* In `RewriteInstance.cpp`, it calls this `Function->updateOutputAddress()` [here](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Rewrite/RewriteInstance.cpp#L3680)
			- All functions in BC is passed to `Function->updateOutputAddress()`, but only ~1200 functions have their `OutputAddress` updated
				+ We still need to go back to the [BinaryFunction::updateOutputValues()](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Core/BinaryFunction.cpp#L4077)
				+ In the first line of this function, it checks whether the functions `isEmitted()`
			- Only If a Binary Function's `isEmitted` is true, its `OutputAddress` has a high chance to be updated
			- When will a Binary Function be set `Emitted`?
				+ In the [BinaryEmitter class](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Core/BinaryEmitter.cpp#L254), a Binary Function is set to be `Emitted`
				+ [Emitted = emitFunction(*Function, /*EmitColdPart=*/false);](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Core/BinaryEmitter.cpp#L244)
				+ [if(!BC.shouldEmit(*Function))](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Core/BinaryEmitter.cpp#L230)
				+ In [BinaryContext::shouldEmit()](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Core/BinaryContext.cpp#L1527), [if(Function.isIgnored())](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Core/BinaryContext.cpp#L1531)
		* Also in `RewriteInstance.cpp`, it updates output addresses based on the new section map and layout. Only do this for the object created by BOLT. [here](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Rewrite/RewriteInstance.cpp#L2971)
	+ We need to know 
		* How `BaseAddress` is updated.
		* How `Layout` is formed.

- How `BaseAddress` is updated
	+ [BaseAddress = getCodeSection()->getOutputAddress();](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Core/BinaryFunction.cpp#L4085)
		* Namely, it uses the starting address of the code section.
		* Need to see where the starting address of the code section is updated.
	+ [Section->setOutputAddress(Address);](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Rewrite/RewriteInstance.cpp#L3438)
		* the starting address is set at this location
		* `Address` is the argument of function [AllocateAt](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Rewrite/RewriteInstance.cpp#L3459)
		* The real value passed to `AllocateAt` to update address is [NextAvailableAddress](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Rewrite/RewriteInstance.cpp#L3475)
	+ `NextAvailableAddress` is a member of `RewriteInstance` class, and is updated [here](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Rewrite/RewriteInstance.cpp#L455)	
	```cpp
455   NextAvailableAddress = 0;
456   uint64_t NextAvailableOffset = 0;
457   ELF64LE::PhdrRange PHs =
458       cantFail(Obj.program_headers(), "program_headers() failed");
459   for (const ELF64LE::Phdr &Phdr : PHs) {
460     switch (Phdr.p_type) {
461     case ELF::PT_LOAD:
462       BC->FirstAllocAddress = std::min(BC->FirstAllocAddress,
463                                        static_cast<uint64_t>(Phdr.p_vaddr     ));
464       NextAvailableAddress = std::max(NextAvailableAddress,
465                                       Phdr.p_vaddr + Phdr.p_memsz);
469       llvm::outs()<<"@@@ "<<utohexstr(NextAvailableAddress)<<"\n";
471       BC->SegmentMapInfo[Phdr.p_vaddr] = SegmentInfo{Phdr.p_vaddr,
472                                                      Phdr.p_memsz,
473                                                      Phdr.p_offset,
474                                                      Phdr.p_filesz,
475                                                      Phdr.p_align};
476       break;
477     case ELF::PT_INTERP:
478       BC->HasInterpHeader = true;
479       break;
480     }
481   }
	```
	+ The output is 
	```
	@@@ 1B22230
	@@@ 38CCD60
	@@@ 3A415B8
	@@@ 42FE3A9
	```
	+ and after [NextAvailableAddress = alignTo(NextAvailableAddress, BC->PageAlign);](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Rewrite/RewriteInstance.cpp#L510), the `NextAvailableAddress` is set to be `0x4400000`


### The order of execution
- first functions got disassembled 
- then functions got emitted
- after functions are emitted, the output address of each function will be updated


### BinaryFunction::disassemble()
- The description of `BinaryFunction::disassemble()` is [here](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/include/bolt/Core/BinaryFunction.h#L2092). 
- In the function, several closures are included: 
	+ [handleExternalReference()](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Core/BinaryFunction.cpp#L1097)
	+ [handleIndirectBranch()](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Core/BinaryFunction.cpp#L1140)
	+ [handleAArch64IndirectCall()](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Core/BinaryFunction.cpp#L1182)
	+ How `BinaryFunction::disassemble()` disassembles call/branch is [here](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Core/BinaryFunction.cpp#L1313)
- only `BinaryFunction::disassemble()` is called only ~1200 times. Why?
	+ need to see its caller function
- The caller of `BinaryFunction::disassemble()` is [RewriteInstance::disassembleFunctions()](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Rewrite/RewriteInstance.cpp#L2674)
	+ iterating on all functions, only ~1200 functions calls `BinaryFunction::disassemble()`, because most of the functions cannot pass [if (!shouldDisassemble(Function))](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Rewrite/RewriteInstance.cpp#L2698)
	+ in [RewriteInstance->shouldDisassemble()](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Rewrite/RewriteInstance.cpp#L430)
		* if a BinaryFunction's `isIgnored` is false, `RewriteInstance->shouldDisassemble()` returns ture
		* we need to see how a BinaryFunction's `isIgnored` is set
	+ in `BinaryFunction` class, there is a [setIgnored()](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/include/bolt/Core/BinaryFunction.h#L1811) function
		* (1) the caller of this function is [RewriteInstance::selectFunctionsToProcess()](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Rewrite/RewriteInstance.cpp#L2491) 
			- the [shouldProcess](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Rewrite/RewriteInstance.cpp#L2546) closure, if BOLT is in lite mode, then only function that has profile will have `shouldProcess` returns true.
			```cpp
if (opts::Lite) 
	if (ProfileReader && !ProfileReader->mayHaveProfileData(Function))
		return false;
			```
			- this means <strong>if a function doesn't have profile, it won't be disassembled.</strong>
		* (2) the caller of this function can also be [RewriteInstance::disassembleFunctions()](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Rewrite/RewriteInstance.cpp#L2715)
			- but the `setIgnored()` happens after `if (!shouldDisassemble(Function))`
		* (3) the caller of this function can also be [BinaryContext::skipMarkedFragments()](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Core/BinaryContext.cpp#L688)
			- but this line is never executed since `FragmentsToSkip.size()` is 0
		* (4) the caller of this function can also be [BinaryContext::adjustCodePadding()](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Core/BinaryContext.cpp#L919)
			- but this line is never executed since (tested to print something but nothing is printed)

### BinaryEmitter::emitFunction()


[MCSymbol *BinaryContext::registerNameAtAddress()](https://github.com/upenn-acg/BOLT/blob/pg2/func-reloc/bolt/lib/Core/BinaryContext.cpp#L939)






