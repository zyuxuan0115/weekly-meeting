---
layout: post
title:  "2022-11-21 BAT-dump usage"
date:   2022-11-20 13:13:46 -0500
categories: cont-opt
---
## Notes about how to use BOLT's BAT-dump infrastructure 
- BAT stands for <em>Bolt Address Translation </em> (table).
   * The detailed explaination of BAT is in the comment of this [BoltAddressTranslation.h](https://github.com/facebookincubator/BOLT/blob/main/bolt/include/bolt/Profile/BoltAddressTranslation.h) file.
- BAT-dump code can be found [here](https://github.com/llvm/llvm-project/tree/main/bolt/tools/bat-dump) .
   * To build BAT-dump, just use the same way as building llvm from source.
   * BAT-dump will be at the `build/bin` directory.
   ```bash
   > git clone https://github.com/llvm/llvm-project.git
   > mkdir build
   > cd build
   > cmake -G "Unix Makefiles" ../llvm-project/llvm -DLLVM_TARGETS_TO_BUILD="X86;AArch64" -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_ASSERTIONS=ON -DLLVM_ENABLE_PROJECTS="bolt"
   > make -j 
  ```
- In the BAT-dump they use [enableFor()](https://github.com/llvm/llvm-project/blob/main/bolt/include/bolt/Profile/BoltAddressTranslation.h#L109) function to test whether a binary has BAT.    
   * If a binary contains BAT, it means this binary is generated by BOLT. (aka, BOLTeb binary)
   * However, BOLT doesn't automatically add BAT into a BOLTed binary. (later on I found that we can manually enable it when running `llvm-bolt` to produce a BOLTed binary. See the following findings)
- To check how to enable BAT (add BAT into a BOLTed binary), I found in [RewriteInstance.cpp](https://github.com/llvm/llvm-project/blob/main/bolt/lib/Rewrite/RewriteInstance.cpp#L2825) 
   * `RewriteInstance::addBATSection()` and `RewriteInstance::encodeBATSection()` are functions that adds BAT to the BOLTed binary.
   * And I also found `if (opts::EnableBAT) addBATSection();` and `if (opts::EnableBAT) encodeBATSection();` in this code. It means if these 2 if statements' predicates are `true`, BAT can be written into the BOLTed binary. And `opts::EnableBAT` is initialized via command line.  
- The code of using command line to enable BAT is in this [link](https://github.com/llvm/llvm-project/blob/main/bolt/lib/Utils/CommandLineOpts.cpp#L69).
   * From this `CommandLineOpts.cpp`, we know that `llvm-bolt` has already added the command line argument to enable "writing BAT into the BOLTed binary".
   * From `llvm-bolt --help-hidden`, we know that the flag `--enable-bat` will enable writing BOLT Address Translation tables into the BOLTed binary.
   * The new commands to produce a BOLTed binary with BAT and get the BAT table is listed below.
   ```bash
   > llvm-bolt {executable} -o {executable}.bolt --enable-bat -data=perf.fdata -reorder-blocks=cache+ -reorder-functions=hfsort
   > llvm-bat-dump --dump-all {executable}.bolt > dump_all.txt
   ```
   
## Notes about the BAT-dump's output
`llvm-bat-dump --dump-all` will output the change of call sites, branches and even arithmetic operations in the following format for each function that is BB reordered and function reordered by BOLT: (This is an example of using BAT-dump on MySQL)
```
Function Address: 0x4800200
BB mappings:
0x0 -> 0x0
0x24 -> 0x24 (branch)
0x26 -> 0x26
0x31 -> 0x31 (branch)
0x33 -> 0x70
0x3c -> 0x79 (branch)
0x3d -> 0x33
0x44 -> 0x3a
0x56 -> 0x4c (branch)
0x57 -> 0x50
0x61 -> 0x5a (branch)
0x63 -> 0x5c
0x75 -> 0x6e (branch)

Function Address: 0x4800280
BB mappings:
0x0 -> 0x0
0x8 -> 0x8 (branch)
0xa -> 0x10
0x11 -> 0x17 (branch)
0x13 -> 0x21
0x16 -> 0x24 (branch)
0x18 -> 0xa
0x1a -> 0xc (branch)
0x1b -> 0x19
0x21 -> 0x1f (branch)
0x25 -> 0x26
0x29 -> 0x2a (branch)

...
```

This is the disassembling of function at `0x4800200` of the BOLTed binary.

```gdb
(gdb) disas 0x4800200
Dump of assembler code for function _ZN20PFS_memory_safe_stat10count_freeEmP26PFS_memory_stat_free_delta:
   0x0000000004800200 <+0>:	endbr64
   0x0000000004800204 <+4>:	mov    0x30(%rdi),%rcx
   0x0000000004800208 <+8>:	addq   $0x1,0x10(%rdi)
   0x000000000480020d <+d>:	addq   $0x1,0x28(%rdi)
   0x0000000004800212 <+12>:	mov    0x40(%rdi),%rax
   0x0000000004800216 <+16>:	add    %rsi,0x20(%rdi)
   0x000000000480021a <+1a>:	add    %rsi,0x38(%rdi)
   0x000000000480021e <+1e>:	movb   $0x1,(%rdi)
   0x0000000004800221 <+21>:	test   %rcx,%rcx
   0x0000000004800224 <+24>:	je     0x4800257 <_ZN20PFS_memory_safe_stat10count_freeEmP26PFS_memory_stat_free_delta+57>
   0x0000000004800226 <+26>:	sub    $0x1,%rcx
   0x000000000480022a <+2a>:	mov    %rcx,0x30(%rdi)
   0x000000000480022e <+2e>:	cmp    %rsi,%rax
   0x0000000004800231 <+31>:	jb     0x480023d <_ZN20PFS_memory_safe_stat10count_freeEmP26PFS_memory_stat_free_delta+3d>
   0x0000000004800233 <+33>:	sub    %rsi,%rax
   0x0000000004800236 <+36>:	mov    %rax,0x40(%rdi)
   0x000000000480023a <+3a>:	xor    %eax,%eax
   0x000000000480023c <+3c>:	ret
   0x000000000480023d <+3d>:	movq   $0x0,(%rdx)
   0x0000000004800244 <+44>:	sub    %rax,%rsi
   0x0000000004800247 <+47>:	mov    %rdx,%rax
   0x000000000480024a <+4a>:	mov    %rsi,0x8(%rdx)
   0x000000000480024e <+4e>:	movq   $0x0,0x40(%rdi)
   0x0000000004800256 <+56>:	ret
   0x0000000004800257 <+57>:	movq   $0x1,(%rdx)
   0x000000000480025e <+5d>:	cmp    %rsi,%rax
   0x0000000004800261 <+61>:	jb     0x4800244 <_ZN20PFS_memory_safe_stat10count_freeEmP26PFS_memory_stat_free_delta+44>
   0x0000000004800263 <+63>:	sub    %rsi,%rax
   0x0000000004800266 <+66>:	mov    %rax,0x40(%rdi)
   0x000000000480026a <+6a>:	mov    %rdx,%rax
   0x000000000480026d <+6d>:	movq   $0x0,0x8(%rdx)
   0x0000000004800275 <+75>:	ret
End of assembler dump.
```

And the following disassembly code is the disassembling of the same function in the original `mysqld` binary.
```gdb
(gdb) disas _ZN20PFS_memory_safe_stat10count_freeEmP26PFS_memory_stat_free_delta
Dump of assembler code for function _ZN20PFS_memory_safe_stat10count_freeEmP26PFS_memory_stat_free_delta:
   0x000000000283c0f0 <+0>:	endbr64
   0x000000000283c0f4 <+4>:	mov    0x30(%rdi),%rcx
   0x000000000283c0f8 <+8>:	addq   $0x1,0x10(%rdi)
   0x000000000283c0fd <+d>:	addq   $0x1,0x28(%rdi)
   0x000000000283c102 <+12>:	mov    0x40(%rdi),%rax
   0x000000000283c106 <+16>:	add    %rsi,0x20(%rdi)
   0x000000000283c10a <+1a>:	add    %rsi,0x38(%rdi)
   0x000000000283c10e <+1e>:	movb   $0x1,(%rdi)
   0x000000000283c111 <+21>:	test   %rcx,%rcx
   0x000000000283c114 <+24>:	je     0x283c140 <_ZN20PFS_memory_safe_stat10count_freeEmP26PFS_memory_stat_free_delta+50>
   0x000000000283c116 <+26>:	sub    $0x1,%rcx
   0x000000000283c11a <+2a>:	mov    %rcx,0x30(%rdi)
   0x000000000283c11e <+2d>:	cmp    %rsi,%rax
   0x000000000283c121 <+31>:	jae    0x283c160 <_ZN20PFS_memory_safe_stat10count_freeEmP26PFS_memory_stat_free_delta+70>
   0x000000000283c123 <+33>:	movq   $0x0,(%rdx)
   0x000000000283c12a <+3a>:	sub    %rax,%rsi
   0x000000000283c12d <+3d>:	mov    %rdx,%rax
   0x000000000283c130 <+40>:	mov    %rsi,0x8(%rdx)
   0x000000000283c134 <+44>:	movq   $0x0,0x40(%rdi)
   0x000000000283c13c <+4c>:	ret
   0x000000000283c13d <+4d>:	nopl   (%rax)
   0x000000000283c140 <+50>:	movq   $0x1,(%rdx)
   0x000000000283c147 <+57>:	cmp    %rsi,%rax
   0x000000000283c14a <+5a>:	jb     0x283c12a <_ZN20PFS_memory_safe_stat10count_freeEmP26PFS_memory_stat_free_delta+3a>
   0x000000000283c14c <+5c>:	sub    %rsi,%rax
   0x000000000283c14f <+5f>:	mov    %rax,0x40(%rdi)
   0x000000000283c153 <+63>:	mov    %rdx,%rax
   0x000000000283c156 <+66>:	movq   $0x0,0x8(%rdx)
   0x000000000283c15e <+6e>:	ret
   0x000000000283c15f <+6f>:	nop
   0x000000000283c160 <+70>:	sub    %rsi,%rax
   0x000000000283c163 <+73>:	mov    %rax,0x40(%rdi)
   0x000000000283c167 <+77>:	xor    %eax,%eax
   0x000000000283c169 <+79>:	ret
End of assembler dump.
```

By comparing these 2 gdb's function disassembling result, we know that, in `llvm-bat-dump --dump-all`'s output, the left column is the offset of instructions in the BOLTed function while the right column is the offset of instructions in the original function. 

For example, in `0x61 -> 0x5a (branch)`, `0x61` in the BOLTed function is `<+61>: jb 0x4800244 <_ZN20PFS_memory_safe_stat10count_freeEmP26PFS_memory_stat_free_delta+44>`, and `0x5a` in the original function is also `<+5a>: jb 0x283c12a <_ZN20PFS_memory_safe_stat10count_freeEmP26PFS_memory_stat_free_delta+3a>`. These 2 `jb` instructions both jump to `sub %rax,%rsi`. So they are actually the same `jb`. 

The execution time of `llvm-bat-dump` is 
```bash
$ time llvm-bat-dump --dump-all mysqld.bolt > dump_all.txt
real	0m0.523s
user	0m0.373s
sys	0m0.101s
```

Conclusion
- `llvm-bat-dump` can print the map relationship between the instructions in the the BOLTed function and instructions in the original function.
- The execution time of `llvm-bat-dump` on a big-code binary such as MySQL is about 0.5 seconds, which is acceptable. 
