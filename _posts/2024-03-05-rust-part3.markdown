---
layout: post
title:  "2024-03-05 Rust part3"
date:   2024-03-05 1:53:49 -0500
categories: serverless functions
---
## Chapter 8
### vector
#### create a vector

```rust
let v1: Vec<i32> = Vec::new();
let v2 = vec![1, 2, 3];
let mut v3 = Vec::new();
v3.push(5);
v3.push(6);
v3.push(7);
v3.push(8);
```

#### Reading Elements of Vectors

- There are two ways to reference a value stored in a vector: via indexing or using the `get` method.
	+ Using `&` and `[]` gives us a reference to the element at the index value.

```rust
let v = vec![1, 2, 3, 4, 5];
let third: &i32 = &v[2];
println!("The third element is {third}");

let third: Option<&i32> = v.get(2);
match third {
   Some(third) => println!("The third element is {third}"),
   None => println!("There is no third element."),
}
```

#### Iterating over the Values in a Vector

```rust
let mut v = vec![100, 32, 57];
for i in &mut v {
   *i += 50;
}
```

here `&mut` means

- We can also iterate over mutable references to each element in a mutable vector in order to make changes to all the elements.
- We have to use the `*` dereference operator to get to the value in `i` before we can use the `+=` operator. 

#### Combining with enum to store multiple types

```rust
enum SpreadsheetCell {
  Int(i32),
  Float(f64),
  Text(String),
}

let row = vec![
  SpreadsheetCell::Int(3),
  SpreadsheetCell::Text(String::from("blue")),
  SpreadsheetCell::Float(10.12),
];
```

- Like any other struct, a vector is freed when it goes out of scope.
- When the vector gets dropped, all of its contents are also dropped.

### String
The `String` type, which is provided by Rust’s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type.

`String` is actually implemented as a wrapper around a vector of bytes with some extra guarantees, restrictions, and capabilities.

#### convert String literal to String

```rust
let s = "initial contents".to_string();
let s = String::from("initial contents");
```

#### Concatenation

```rust
let mut s = String::from("foo");
s.push_str("bar");

let mut s = String::from("lo");
s.push('l');

let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
```

- we can only add a &str to a String; we can’t add two String values together

#### the `format!` macro

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{s1}-{s2}-{s3}");
```

The `format!` macro works like `println!`, but instead of printing the output to the screen, it returns a String with the contents.

#### UTF-8
	+ Rust string is in UTF-8 so each charactor may be 1 byte, 2 bytes ... So It doesn't support string indexing.
	+ to iterate over strings, the best way is this:

```rust
for c in "Зд".chars() {
    println!("{c}");
}
// output
// З
// д
```

or

```rust
for b in "Зд".bytes() {
    println!("{b}");
}
// output
// 208
// 151
// 208
// 180
```

### HashMap
The type `HashMap<K, V>` stores a mapping of keys of type K to values of type V using a hashing function, which determines how it places these keys and values into memory.

#### Creating a New Hash Map

```rust
use std::collections::HashMap;
let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
```

#### Accessing Values in a Hash Map

```rust
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name).copied().unwrap_or(0);
```

The get method returns an `Option<&V>`; if there’s no value for that key in the hash map, get will return `None`. This program handles the `Option` by calling copied to get an `Option<i32>` rather than an `Option<&i32>`, then `unwrap_or` to set score to zero if scores doesn't have an entry for the key.

- iterate over each key/value pair in a hash map 

```rust
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

for (key, value) in &scores {
  println!("{key}: {value}");
}
```

#### Ownership 

For owned values like String, the values will be moved and the hash map will be the owner of those values

```rust
use std::collections::HashMap;

let field_name = String::from("Favorite color");
let field_value = String::from("Blue");

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name and field_value are invalid at this point, try using them and
// see what compiler error you get!
```

We aren’t able to use the variables `field_name` and `field_value` after they’ve been moved into the hash map with the call to insert.

#### Adding a Key and Value Only If a Key Isn’t Present

```rust
let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);

scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);

println!("{:?}", scores);
```

#### Updating a Value Based on the Old Value

```rust
let text = "hello world wonderful world";

let mut map = HashMap::new();

for word in text.split_whitespace() {
   let count = map.entry(word).or_insert(0);
   *count += 1;
}

println!("{:?}", map);
```

note: The `or_insert` method returns a mutable reference `(&mut V)` to the value for the specified key.


## Chapter 9
### Panic
There are two ways to cause a panic:
- taking an action that causes our code to panic
- explicitly calling the `panic!` macro

To backtrace a panic, we can run 

```bash
RUST_BACKTRACE=1 cargo run
```

Debug symbols are enabled by default when using `cargo build` or `cargo run` without the `--release` flag, as we have here

### Recoverable Errors with Result

```rust
enum Result<T, E> {
   Ok(T),
   Err(E),
}
```

like the `Option` enum, the `Result` enum and its variants have been brought into scope by the prelude, so we don’t need to specify `Result::` before the `Ok` and `Err` variants in the match arms.

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => {
                panic!("Problem opening the file: {:?}", other_error);
            }
        },
    };
}
```

### Shortcuts for Panic on Error: unwrap and expect
- If the `Result` value is the `Ok` variant, `unwrap` will return the value inside the `Ok`. If the Result is the `Err` variant, `unwrap` will call the `panic!` macro for us.

```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}
```

- Using `expect` instead of `unwrap` and providing good error messages can convey your intent and make tracking down the source of a panic easier. 

- The error message used by `expect` in its call to `panic!` will be the parameter that we pass to `expect`, rather than the default `panic!` message that `unwrap` uses

```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}
```

### Propagating Errors
Instead of handling the error within the function itself, you can return the error to the calling code so that it can decide what to do. This is known as <strong>propagating the error</strong>.

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
```

This pattern of propagating errors is so common in Rust that Rust provides the question mark operator `?` to make this easier.


#### A Shortcut for Propagating Errors: the ? Operator

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
```

If the value of the `Result` is an `Ok`, the value inside the `Ok` will get returned from this expression, and the program will continue. If the value is an `Err`, the `Err` will be returned from the whole function as if we had used the return keyword so the error value gets propagated to the calling code.
