---
layout: post
title:  "2024-03-10 Rust part4 (closure)"
date:   2024-03-10 1:53:49 -0500
categories: serverless functions
---

## Chapter 13
<strong>Programming in a functional style often includes using functions as values by passing them in arguments, returning them from other functions, assigning them to variables for later execution, and so forth. </strong>

### Closure

- Rust’s closures are anonymous functions you can save in a variable or pass as arguments to other functions. 
- You can create the closure in one place and then call the closure elsewhere to evaluate it in a different context. 
- Unlike functions, closures can capture values from the scope in which they’re defined.

```rust
#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec<ShirtColor>,
}

impl Inventory {
    fn giveaway(&self, user_preference: Option<ShirtColor>) -> ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&self) -> ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &self.shirts {
            match color {
                ShirtColor::Red => num_red += 1,
                ShirtColor::Blue => num_blue += 1,
            }
        }
        if num_red > num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref2, giveaway2
    );
}
```
Notes:
- The `unwrap_or_else` method on `Option<T>` is defined by the standard library. It takes one argument: a closure without any arguments that returns a value `T` (the same type stored in the Some variant of the `Option<T>`
- If the `Option<T>` is the `Some` variant, `unwrap_or_else` returns the value from within the `Some`. If the `Option<T>` is the `None` variant, `unwrap_or_else` calls the closure and returns the value returned by the closure.
- We specify the closure expression `|| self.most_stocked()` as the argument to `unwrap_or_else`. 
	+ if the closure had parameters, they would appear between the two vertical bars.

- Closures don’t usually require you to annotate the types of the parameters or the return value like fn functions do.

<strong>An example of defining a closure</strong>

```rust
let expensive_closure = |num: u32| -> u32 {
  println!("calculating slowly...");
  thread::sleep(Duration::from_secs(2));
  num
};
```

<strong>fn vs. closure</strong>

```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

`add_one_v3` and `add_one_v4` lines require compiler to infer the type of `x` when `add_one_v3` and `add_one_v4` are called.

#### Capturing References or Moving Ownership
Closures can capture values from their environment in three ways:
- borrowing immutably
- borrowing mutably
- taking ownership
	+ If you want to force the closure to take ownership of the values it uses in the environment even though the body of the closure doesn’t strictly need ownership, you can use the `move` keyword before the parameter list. 

```rust
use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

    thread::spawn(move || println!("From thread: {:?}", list))
        .join()
        .unwrap();
}
```

We spawn a new thread, giving the thread a closure to run as an argument.

#### Moving Captured Values Out of Closures and the Fn Traits

- Closures will automatically implement one, two, or all three of these `Fn` traits
	+ `FnOnce` applies to closures that can be called once. 
		* A closure that moves captured values out of its body will only implement `FnOnce` and none of the other `Fn` traits, because it can only be called once.
	+ `FnMut` applies to closures that don’t move captured values out of their body, but that might mutate the captured values. These closures can be called more than once.
	+ `Fn` applies to closures that don’t move captured values out of their body and that don’t mutate captured values, as well as closures that capture nothing from their environment. These closures can be called more than once without mutating their environment, which is important in cases such as calling a closure multiple times concurrently.

- `FnOnce` example 

```rust
impl<T> Option<T> {
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T
    {
        match self {
            Some(x) => x,
            None => f(),
        }
    }
}
```

- `FnMut` example

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{:#?}", list);
}
```

`r.width` can be called multiple times.

### Iterators

When you use iterators, you don’t have to reimplement that logic yourself.

In Rust, iterators are <strong>lazy</strong>, meaning they have no effect until you call methods that consume the iterator to use it up.

```rust
let v1 = vec![1, 2, 3];
let v1_iter = v1.iter();
for val in v1_iter {
  println!("Got: {}", val);
}
```

#### The Iterator Trait and the next Method

```rust
pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
    // methods with default implementations elided
}
```

Implementing the Iterator trait requires that you also define an Item type, and this `Item` type is used in the return type of the `next` method. In other words, the `Item` type will be the type returned from the iterator.

The Iterator trait only requires implementors to define one method: the next method, which returns one item of the `iterator` at a time wrapped in `Some` and, when iteration is over, returns `None`.

```rust
fn iterator_demonstration() {
  v1 = vec![1, 2, 3];
  let mut v1_iter = v1.iter();

  assert_eq!(v1_iter.next(), Some(&1));
  assert_eq!(v1_iter.next(), Some(&2));
  assert_eq!(v1_iter.next(), Some(&3));
  assert_eq!(v1_iter.next(), None);
}
```

Note that we needed to make `v1_iter` mutable: calling the next method on an iterator changes internal state that the iterator uses to keep track of where it is in the sequence.

We didn’t need to make `v1_iter` mutable when we used a for loop because the loop took ownership of `v1_iter` and made it mutable behind the scenes.

- The iter method produces an iterator over immutable references.
	+ the values we get from the calls to `next` are immutable references to the values in the vector.
	+ If we want to create an iterator that takes ownership of `v1` and returns owned values, we can call `into_iter` instead of `iter`.

#### Methods that Consume the Iterator
Methods that call next are called <strong>consuming adaptors</strong>, because calling them uses up the iterator.

```rust
fn iterator_sum() {
  let v1 = vec![1, 2, 3];
  let v1_iter = v1.iter();
  let total: i32 = v1_iter.sum();
  assert_eq!(total, 6);
}
```

- <strong>sum method</strong>
takes ownership of the iterator and iterates through the items by repeatedly calling `next`, thus consuming the iterator. As it iterates through, it adds each item to a running total and returns the total when iteration is complete.

We aren’t allowed to use `v1_iter` after the call to `sum` because `sum` takes ownership of the iterator we call it on.

#### Methods that Produce Other Iterators

`Iterator adaptors` are methods defined on the `Iterator` trait that don’t consume the iterator.

Instead, they produce different iterators by changing some aspect of the original iterator.


